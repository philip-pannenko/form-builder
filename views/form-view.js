var app = app || {};
(function ($) {
  'use strict';
  app.FormView = Backbone.View.extend({

    el: '.content',

    events: {
      'click #submit': 'submitForm'
    },

    model: app.Form,

    initialize: function () {

      this.model = new app.Form();

      // Go through each form schema element and add it to the form model
      _.each(app.FormSchema, function (element) {

        if (element.model) {
          // Assign the values from the form to the form model
          if (!_.isUndefined(element.default)) {
            this.model.createModel(element.model, element.default);
          } else {
            this.model.createModel(element.model, null);
          }
        }

        // Create a Backbone model and add it to the collection of Element models
        var elementModel = new app.Element(element);
        this.model.attributes.elements.add(elementModel);

        if (!this.model.attributes.modelDomIds[element.model]) {
          this.model.attributes.modelDomIds[element.model] = [];
        }

        this.model.attributes.modelDomIds[element.model].push(element.id);

        // Reverse lookup element by domId
        this.model.attributes.domIdElement[element.id] = elementModel;

      }, this);

      // Go through each behavior schema and add it the the form model
      _.each(app.RulesSchema, function (ruleSchema) {
        var formRule = new jsrules.Rule(ruleSchema.name);

        _.each(ruleSchema.rules, function (rule) {

          if (rule.type === app.BehaviorType.Proposition) {
            formRule.addProposition(rule.model, rule.value);
          } else if (rule.type === app.BehaviorType.Variable) {
            formRule.addVariable(rule.model, null); // this is needed to fulfill jsrule template
            formRule.addVariable(rule.model + 'expected-', rule.value);
            formRule.addOperator(rule.operator.name);
          } else if (rule.type === app.BehaviorType.Operator) {
            formRule.addOperator(rule.operator.name);
          }

          // Reverse lookup rules by modelName
          if (rule.type !== app.BehaviorType.Operator) {
            if (!this.model.attributes.modelRules[rule.model]) {
              this.model.attributes.modelRules[rule.model] = [];
            }
            this.model.attributes.modelRules[rule.model].push(formRule);
          }
        }, this);

        // TODO: There's got to be a safer and more conventional way in Javascript to add a property to an existing 3rd party object (jsrule.Rule in this case)
        formRule.target = ruleSchema.target;
        formRule.targetAttribute = ruleSchema.targetAttribute;

        // Add lookup of rule by behavior name
        this.model.attributes.rules[ruleSchema.name] = formRule;

      }, this);

      // Any time an Element model is changed, update the Form model
      Backbone.on('model-changed', this.updateModel, this);

      // console.log('rendering FormView');
      this.$el.append(
        '<div>' +
        ' <h5>Generated Form</h5>' +
        ' <p>This form has been entirely generated from a JSON configuration file including individual input validation and form rules. ' +
        'Check out the <a href="#formResults">Form Results</a> to see how interacting with the form affects the bound values. ' +
        'The label associated with ice cream, "<b>Whip cream and sprinkles w/ ice cream is awesome!</b>" is a good reference for demonstrating a few ' +
        'capabilities of how the ordered cascading rules are leveraged. Try to enable the ice cream label while having "<b>Show Dessert Menu?</b>" set to "<i>No thanks.</i>". ' +
        'Hint: Take a look at the <a href="#ruleSchema">Rule Schema</a> for the secret number or name.</p>' +
        ' <form id="form"></form>' +
        '</div>' +
        // '<input id="submit" class="button-primary" type="submit" value="Submit Form">' +
        '<div class="section" id="formResults">' +
        ' <h5>Live Form Model </h5>' +
        ' <p>The values below represent a live cascaded representation of the form after all rules and validations have been performed</p>' +
        ' <table id="results" class="u-full-width"><thead><tr><th>Model</th><th>Value(s)</th></tr></thead><tbody></table>' +
        '</div>' +
        '<div class="section" id="drivenBy">' +
        ' <h5> Form Elements that are Affected By Others </h5>' +
        ' <p>This view shows how a form element is affected by specified model values. Each form element element is only aware of itself from this perspective.</p>' +
        ' <table id="driven" class="u-full-width"><thead><tr><th>Target DomId</th><th>Rule Name</th><th>Target Condition</th><th>Model</th><th>Operation</th><th>Value</th><th>Affected by DomIds</tr></thead><tbody></table>' +
        '</div>' +
        '<div class="section" id="drives">' +
        ' <h5> Form Element that Affect Others </h5>' +
        ' <p>This view shows how a form element affects other elements. This view is actually generated by traversing the rule list a multiple times to build an accurate representation.</p>' +
        ' <table id="driving" class="u-full-width"><thead><tr><th>DomId</th><th>Rule Name</th><th>Target DomId</th><th>Target Condition</th><th>Model</th><th>Operation</th><th>Value</th></tr></thead><tbody></table>' +
        '</div>' +
        '<div class="section" id="formSchema">' +
        ' <h5> Configuration Used to Generate Form </h5>' +
        ' <p>The following code was used to generate the form.</p>' +
        ' <pre><code> ' + JSON.stringify(app.FormSchema, function (name, val) {
          if (name === 'type') return val.type; else if (name === 'method') return val.name; else return val;
        }, 4) + '</code></pre>' +
        '</div>' +
        '<div class="section" id="ruleSchema">' +
        ' <h5> Configuration Used to Assign Rules to Form </h5>' +
        ' <p>The following code was used to generate rules on the form. Notice that chained rules are done so using <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse-Polish</a> notation.</p>' +
        ' <pre><code> ' + JSON.stringify(app.RulesSchema, function (name, val) {
          if (name === 'type') return val.type; else if (name === 'operator') return val.name; else return val;
        }, 4) + '</code></pre>' +
        '</div>');


      this.$results = $('#results tbody');
      this.$driven = $('#driven tbody');
      this.$driving = $('#driving tbody');

      this.model.attributes.elements.each(function (element) {
        this.$('#form').append(new app.ElementView({model: element}).render().$el);
      }, this);

      // Run all of the behaviors to render actual interacted form
      _.each(this.model.attributes.modelRules, function (ruleName, model) {
        this.runFormRules(model);
      }, this);

      this.render();

      this.drivenRules();
      this.drivingRules();

    },

    // TODO: Confusing parameters names should be fixed
    drivenRules: function () {
      var drivenRules = [];

      // Step 1: Get the target and rule name of each rule
      _.each(this.model.attributes.rules, function (rule) {
        var drivenRule = {
          targetDomId: rule.target,
          rule: rule.name,
          condition: rule.targetAttribute,
          driven: [] // [ {model: modelName, value: value, operator: operator}, ... }
        };

        // Step 2: Get all models associated with the rule
        var grabOp = null;
        _.each(rule.elements, function (element) {
          if (element.type === 'jsrules.Proposition') {
            drivenRule.driven.push({model: element.name, value: element.value, operator: app.Operator.EQUALTO.value});
          } else if (element.type === 'jsrules.Variable') {
            if (element.name.includes('expected-')) {
              var model = element.name.substring(0, element.name.indexOf('expected-'));
              var drive = {model: model, value: element.value};
              drivenRule.driven.push(drive);
              grabOp = drive;
            }
          } else if (element.type === 'jsrules.Operator') {
            if (grabOp) {
              grabOp.operator = app.Operator[element.name].value;
              grabOp = null;
            }
          }
        }, this);

        // Step 3: Get all domIds associated with the models
        _.each(drivenRule.driven, function (driven) {
          driven.domIds = (this.model.attributes.modelDomIds[driven.model]);
        }, this);

        drivenRules.push(drivenRule);
      }, this);

      var template = _.template('<tr><td><%= targetDomId %></td><td><%= rule %></td><td><%= targetCondition %></td><td><%= model %></td><td><%= operation %></td><td><%= value %></td><td><%= domId %></td></tr>');
      this.$driven.empty();

      _.each(drivenRules, function (drivenRule) {
        var first = true;
        _.each(drivenRule.driven, function (driven) {
          this.$driven.append(template({
            targetDomId: first ? drivenRule.targetDomId : '',
            rule: first ? drivenRule.rule : '',
            targetCondition: first ? drivenRule.condition : '',
            model: driven.model,
            operation: driven.operator,
            value: driven.value,
            domId: _.values(driven.domIds).toString()
          }));
          first = false;
        }, this);
      }, this);
    },

    // TODO: Confusing parameters names should be fixed
    drivingRules: function () {

      var drivingRules = [];

      // Step 1: Get unique models associated with all rules
      var models = [];
      _.each(this.model.attributes.rules, function (rule) {
        _.each(rule.elements, function (element) {
          if ((element.type === 'jsrules.Proposition' || element.type === 'jsrules.Variable') && !element.name.includes('expected-')) {
            models.push(element.name);
          }
        }, this);
      }, this);
      models = _.uniq(models);

      // Step 2: Get all domIds for each model found to be associated with a rule
      var domIdModels = {};
      _.each(models, function (model) {
        // get all dom
        _.each(this.model.attributes.modelDomIds[model], function (domId) {
          if (!domIdModels[domId]) {
            domIdModels[domId] = [];
          }
          domIdModels[domId].push(model);
        }, this);
      }, this);

      // Step 3: Find each rule the domIds are found in and grab that all of that rule's targetDomIds and name
      _.each(domIdModels, function (models, domId) {
        var drivingRule = {
          domId: domId,
          drives: []
        };

        var found = false;

        _.each(this.model.attributes.rules, function (rule) {

          var drive = {
            rule: rule.name,
            target: rule.target,
            condition: rule.targetAttribute,
            drive: []
          };

          drivingRule.drives.push(drive);

          var grabOp = null;
          _.each(rule.elements, function (element) {
            if (element.type === 'jsrules.Proposition') {
              if (!found) {
                found = _.contains(models, element.name);
              }
              drive.drive.push({model: element.name, value: element.value, operator: app.Operator.EQUALTO.value});

            } else if (element.type === 'jsrules.Variable' && element.name.includes('expected-')) {

              var model = element.name.substring(0, element.name.indexOf('expected-'));
              if (!found) {
                found = _.contains(models, model);
              }

              grabOp = {model: model, value: element.value, operator: app.Operator.EQUALTO.value};
              drive.drive.push(grabOp);
            } else if (element.type === 'jsrules.Operator') {
              if (grabOp) {
                grabOp.operator = app.Operator[element.name].value;
                grabOp = null;
              }
            }

          }, this);
        }, this);

        if (found) {
          drivingRules.push(drivingRule);
        }

      }, this);

      // Step 4: Render the tempalte
      // Target DomId | Rule | Model | Operation | Value | Target Dom Id | Condition
      //              |      | Model | Operation | Value | Target Dom Id | Condition
      //              | Rule | Model | Operation | Value | Target Dom Id | Condition
      var template = _.template('<tr><td><%= domId %></td><td><%= rule %></td><td><%= targetDomId %></td><td><%= targetCondition %></td><td><%= model %></td><td><%= operation %></td><td><%= value %></td></tr>');
      this.$driving.empty();
      _.each(drivingRules, function (drivingRule) {
        var first = true;

        _.each(drivingRule.drives, function (drive1) {
          var second = true;
          _.each(drive1.drive, function (drive) {
            this.$driving.append(template({
              domId: first ? drivingRule.domId : '',
              rule: second ? drive1.rule : '',
              targetDomId: second ? drive1.target : '',
              targetCondition: second ? drive1.condition : '',
              model: drive.model,
              operation: drive.operator,
              value: drive.value.toString()

            }));
            second = false;
            first = false;
          }, this);


        }, this);
      }, this);
    },

    runFormRules: function (model) {

      // Find all rules associated with the model property changed
      _.each(this.model.attributes.modelRules[model], function (rule) {
        console.log('running Rule(' + rule.name + ')');
        var fact = new jsrules.RuleContext(rule.name + '-fact');

        // Build the jsrule to execute
        _.each(rule.elements, function (element) {
          if (element.type === 'jsrules.Proposition') {
            fact.addProposition(element.name, this.model.attributes.model[element.name]);
          } else if (element.type === 'jsrules.Variable') {
            if (typeof this.model.attributes.model[element.name] != 'undefined') {
              fact.addVariable(element.name, this.model.attributes.model[element.name]);
            } else {
              fact.addVariable(element.name, null); // add placeholder for JSRules to be able to lookup rule
            }
          }
        }, this);

        // Run the jsRule against all Elements that's bound to that model
        var element = this.model.attributes.domIdElement[rule.target];

        // Run the jsRule using real-time model values to generate a true or false
        var ruleResult = rule.evaluate(fact).value;

        // If the rule is found to be valued differently than the previous value, update the model associated with the rule
        if (element.attributes[rule.targetAttribute] !== ruleResult) {
          console.log('rule(' + rule.name + ') caused dom-id(' + rule.target + ') attribute(' + rule.targetAttribute + ') to change to ' + ruleResult);

          // Update the Element properties causing the Element View to be re-rendered.
          element.changeAttribute(rule.targetAttribute, ruleResult);
        }

      }, this);
    },

    updateModel: function (domIdUpdated, model, value) {

      if (this.model.updateModel(model, value)) {
        this.runFormRules(model, value);

        _.each(this.model.attributes.modelDomIds[model], function (domId) {

          // Don't update the value that was just update to prevent a recursive chain
          // TODO: Clean this recursive chain up by passing the calling domId chain into the event
          if (domIdUpdated !== domId) {
            var element = this.model.attributes.elements.get(domId);
            element.set('value', value);
          }

        }, this);

        // Then trigger any ancillary elements that need to be changed because of one thing or another...
        console.log('model(' + model + ') changed to: ' + value);
        Backbone.trigger(model + '-changed', model, value);

        this.render();
      }
    },

    submitForm: function () {
      console.log(this.model.attributes.model);
    },

    render: function () {

      var template = _.template('<tr><td><%= model %></td><td><%= value %></td></tr>');
      this.$results.empty();
      _.each(this.model.attributes.model, function (value, model) {

        if (_.isObject(value)) {
          this.$results.append(template({model: model, value: _.values(value).toString()}));
        } else if (_.isArray(value)) {
          this.$results.append(template({model: model, value: value.toString()}));
        } else {
          this.$results.append(template({model: model, value: value}));
        }
      }, this);

      return this;
    }


  });
})(jQuery);